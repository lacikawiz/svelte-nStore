let z=[];function Y(t){let e=[],r=(r,o=!0)=>(e.includes(r)||e.push(r),o&&r(t),()=>{e=e.filter(t=>t!=r)});function o(r){if(r===t&&(null===t||"object"!=typeof t))return;let o=t;t=r;for(let r of e)r(t,o)}return"function"==typeof t?computed(t):{subscribe:r,set:o,get:function(){let e=z[z.length-1];return e&&r(e[0],!1),t},update:e=>{"function"==typeof e&&o(e(t))}}}function computed(t){let e=Y(null),r=[o];return o(),e;function o(){if(z.includes(r))throw Error("Circular computation");let o;z.push(r);try{o=t()}catch(t){throw z.pop(),t}z.pop(),e.set(o)}}export default Y;
